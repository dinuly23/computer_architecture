// **********************
// *модуль register_file*
// **********************
// = Входы =
// [шина] rn1  [2 ]: номер первого регистра, с которого читается значение
// [шина] rn2  [2 ]: номер второго регистра, с которого читается значение
// [шина] wn   [2 ]: номер регистра, в который хочется записать новое значение
// [бит ] w        : требуется ли записать данные (по переднему фронту clock)
// [бит ] rst      : синхронный сброс всех значений регистров (запись значения 0 во все регистры)
// [бит ] clk      : тактовый сигнал
// [шина] wd   [16]: данные, которые требуется записать в регистр с номером wn
//
// = Выходы =
// [шина] rd1 [16]: данные, считываемые из регистра с номером rn1
// [шина] rd2 [16]: данные, считываемые из регистра с номером rn2
//
// = Функционирование =
// В блоке регистров содержится 4 регистра, каждый - ширины 16.
// Регистры пронумерованы от 0 до 3.
// При запуске значения регистров неопределены (xx...x).
// Значения регистров изменяются по переднему фронту сигнала clk:
// * если "rst == 1", то во все регистры записывается 0;
// * если "rst == 0" и "w == 1", то в регистр с номером wn записывается значение wd.
// На выход rd1 непрерывно выдаётся значение регистра с номером rn1.
// На выход rd2 непрерывно выдаётся значение регистра с номером rn2.
module register_file(rn1, rn2, wn, w, rst, clk, wd, rd1, rd2);
  input [1:0] rn1, rn2, wn;
  input w, rst, clk;
  input [15:0] wd;
  output [15:0] rd1, rd2;
  
  wire [15:0] r_out[0:3];
  wire loads[0:3];
  
  // собственно регистры
  genvar k;
  for(k = 0; k < 4; k = k + 1) begin : gen_block
    register_sload_sreset #(.W(16), .DV(0)) _r0(.i(wd), .l(loads[k]), .clk(clk), .rst(rst), .o(r_out[k]));
  end
  
  // доведение сигнала записи до регистров, т.е. установка loads
  demux #(.DW(1), .CW(2)) _load_signal(
    .i(w),
    .s(wn),
    .o({loads[0], loads[1], loads[2], loads[3]})
  );
  
  // вывод значения rd1
  mux #(.DW(16), .CW(2)) _rd1_reader(
    .i({r_out[0], r_out[1], r_out[2], r_out[3]}),
    .s(rn1),
    .o(rd1)
  );
  
  // вывод значения rd2
  mux #(.DW(16), .CW(2)) _rd2_reader(
    .i({r_out[0], r_out[1], r_out[2], r_out[3]}),
    .s(rn2),
    .o(rd2)
  );
endmodule
